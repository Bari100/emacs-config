:PROPERTIES:
:header-args: :results silent
:END:
#+title: Emacs Config
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes

* Package System Setup

#+begin_src emacs-lisp

  ;; Initialize package sources
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")))

  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))

    ;; Initialize use-package on non-Linux platforms
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)
  (setq use-package-always-ensure t)

  ;; quelpa
  (unless (package-installed-p 'quelpa)
    (with-temp-buffer
      (url-insert-file-contents "https://raw.githubusercontent.com/quelpa/quelpa/master/quelpa.el")
      (eval-buffer)
      (quelpa-self-upgrade)))

  ;; quelpa-use-package
  (quelpa
   '(quelpa-use-package
     :fetcher git
     :url "https://github.com/quelpa/quelpa-use-package.git"))
  (require 'quelpa-use-package)
#+end_src

* Quitting
#+begin_src emacs-lisp
(setq confirm-kill-emacs 'y-or-n-p)
#+end_src

* Keybinding Configuration

** View mode

#+begin_src emacs-lisp
  (defun my/view-mode-enter ()
    "Enter view-mode if not already in it."
    (interactive)
    (unless view-mode
      (view-mode 1)))

  (defun my/view-mode-exit ()
    "Exit view-mode if currently in it."
    (interactive)
    (when view-mode
      (view-mode -1)))

  (define-key input-decode-map [?\C-\[] [ctrl-left-bracket])
  (global-set-key [ctrl-left-bracket] 'my/view-mode-enter)
  ;;(global-set-key (kbd "M-[") 'my/view-mode-enter)

  (with-eval-after-load "view"
    (define-key view-mode-map (kbd "n") 'next-line)
    (define-key view-mode-map (kbd "p") 'previous-line)
    (define-key view-mode-map (kbd "f") 'forward-char)
    (define-key view-mode-map (kbd "b") 'backward-char)
    (define-key view-mode-map (kbd "a") 'move-beginning-of-line)
    (define-key view-mode-map (kbd "e") 'move-end-of-line)
    (define-key view-mode-map (kbd "v") 'scroll-up-command)
    (define-key view-mode-map (kbd "<") 'beginning-of-buffer)
    (define-key view-mode-map (kbd ">") 'end-of-buffer)
    (define-key view-mode-map (kbd "m") 'back-to-indentation)
    (define-key view-mode-map (kbd "x") (make-sparse-keymap))
    (define-key view-mode-map (kbd "x s") 'save-buffer)
    (define-key view-mode-map (kbd "i") 'my/view-mode-exit))
#+end_src

* UI Configuration

** Color Theme

#+begin_src emacs-lisp

(use-package doom-themes
  :init (load-theme 'doom-palenight t))

#+end_src

** Vertico, consult, orderless, marginalia, embark

#+begin_src emacs-lisp
  ;; Enable vertico
  (use-package vertico
    :ensure t
    :init
    (vertico-mode))

  ;; Orderless for better matching
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless))       ;; Use orderless matching
    (completion-category-defaults nil)     ;; Disable default styles per category
    (completion-category-overrides '((file (styles partial-completion))))) ;; Better file completion

  ;; Marginalia for annotations
  (use-package marginalia
    :ensure t
    :init
    (marginalia-mode))

  ;; Consult for enhanced commands
  (use-package consult
    :ensure t
    :bind (;; Buffer switching
           ("C-x b" . consult-buffer)
           ;; Searching
           ("C-s" . consult-line)
           ("M-y" . consult-yank-pop)
           ;; File find
           ("C-x C-f" . consult-find)
           ;; Ripgrep (requires ripgrep installed)
           ("C-c s" . consult-ripgrep)
           ))

  ;; Embark for actions on candidates
  (use-package embark
    :ensure t
    :bind
    (("C-." . embark-act)         ;; like a right-click menu for minibuffer
     ("C-;" . embark-dwim))       ;; do what I mean
    :init
    ;; Use Embark to show the context menu in the minibuffer
    (setq prefix-help-command #'embark-prefix-help-command))

  ;; Optional: Embark + Consult Preview
  (use-package embark-consult
    :after (embark consult)
    :ensure t)

  ;; Enable recent files in consult-buffer
  ;;(recentf-mode 1)
  ;;(setq recentf-max-menu-items 25
  ;;      recentf-max-saved-items 100)

#+end_src
* Development

** Treesitter

*** treesit-auto

#+begin_src emacs-lisp
(use-package treesit-auto
  :custom
  (treesit-auto-install 'prompt)
  :config
  (treesit-auto-add-to-auto-mode-alist 'all)
  (global-treesit-auto-mode))
#+end_src

** TypeScript

#+begin_src emacs-lisp
  ;;  (use-package typescript-mode
  ;;  ;;  :mode "\\.ts\\'"
  ;;  ;;  :hook (typescript-mode . lsp-deferred)
  ;;    :config
  ;;    (setq typescript-indent-level 2))
  ;;
  ;;(setq css-indent-offset 2)
    (use-package typescript-mode
      :after tree-sitter
    ;;  :mode "\\.ts\\'"
    ;;  :hook (typescript-mode . lsp-deferred)
      :config
      (define-derived-mode typescriptreact-mode typescript-mode
      "TypeScript TSX")
      (add-to-list 'auto-mode-alist '("\\.tsx?\\'" . typescriptreact-mode))
      (add-to-list 'tree-sitter-major-mode-language-alist '(typescriptreact-mode . tsx))
      (setq typescript-indent-level 2))

  (setq css-indent-offset 2)

#+end_src

*Important note!*  For =lsp-mode= to work with TypeScript (and JavaScript) you will need to install a language server on your machine.  If you have Node.js installed, the easiest way to do that is by running the following command:

#+begin_src shell :tangle no

npm install -g typescript-language-server typescript

#+end_src

** Emacs lisp

*** Prism

Disperses lisp forms (and other languages) into a spectrum of color by depth. 

#+begin_src emacs-lisp
  (use-package prism
    :quelpa (prism :fetcher github :repo "alphapapa/prism.el"))
#+end_src

** eglot


#+begin_src emacs-lisp
    ;; --- Eglot + ts-ls (typescript-language-server) ---
    ;; Requires: npm i -g typescript-language-server typescript
  ;;  (use-package eglot
  ;;    :ensure t
  ;;    :hook ((typescript-ts-mode tsx-ts-mode js-ts-mode js-mode) . eglot-ensure)
  ;;    :config
  ;;    ;; Tell Eglot to use ts-ls for these modes
  ;;    (add-to-list 'eglot-server-programs
  ;;                 '((typescript-ts-mode tsx-ts-mode js-ts-mode js-mode)
  ;;                   . ("typescript-language-server" "--stdio")))
  ;;
  ;;    ;; Prefer project-local node_modules/.bin if present (tsserver, ts-ls)
  ;;    (defun my/eglot-node-path ()
  ;;      (when-let* ((root (or (project-root (project-current nil))
  ;;                            (locate-dominating-file default-directory "package.json")))
  ;;                  (bin  (expand-file-name "node_modules/.bin" root)))
  ;;        (when (file-exists-p bin)
  ;;          (make-local-variable 'exec-path)
  ;;          (add-to-list 'exec-path bin)
  ;;          (setenv "PATH" (concat bin path-separator (getenv "PATH"))))))
  ;;    (add-hook 'eglot-managed-mode-hook #'my/eglot-node-path))
  ;;
  ;;(setq eglot-stay-out-of '(flymake))
  ;;
  ;;(add-hook 'eglot-managed-mode-hook
  ;;          (lambda ()
  ;;            (flymake-mode -1)
  ;;            (flycheck-mode 1)))

    ;; Optional: auto-format with the server on save (uncomment if wanted)
    ;; (add-hook 'eglot-managed-mode-hook
    ;;           (lambda () (add-hook 'before-save-hook #'eglot-format-buffer nil t)))


  (use-package eglot
    ;; :straight nil
    :custom
    (eglot-autoshutdown t)
    :hook
    (eglot-managed-mode . me/flymake-eslint-enable-maybe)
    (typescript-ts-base-mode . eglot-ensure)
    :init
    (put 'eglot-server-programs 'safe-local-variable 'listp)
    :config
    ;; (add-to-list 'eglot-stay-out-of 'eldoc-documentation-strategy)
    ;; (put 'eglot-error 'flymake-overlay-control nil)
    ;; (put 'eglot-warning 'flymake-overlay-control nil)
    (setq eglot-confirm-server-initiated-edits nil)
    (advice-add 'eglot--apply-workspace-edit :after #'me/project-save)
    (advice-add 'project-kill-buffers :before #'me/eglot-shutdown-project)
    :preface
    (defun me/eglot-shutdown-project ()
      "Kill the LSP server for the current project if it exists."
      (when-let ((server (eglot-current-server)))
        (ignore-errors (eglot-shutdown server)))))
#+end_src

** Flymake

#+begin_src emacs-lisp
    ;;  (use-package flymake-eslint
    ;;    :ensure t
    ;;    :hook ((js-ts-mode tsx-ts-mode typescript-ts-mode) . flymake-eslint-enable))
    ;;
    ;;

    ;;; --- Flymake + ESLint (stdin/json), no project edits required ---
    ;;; -*- lexical-binding: t; -*-
    ;;; Flymake + ESLint via stdin/json (shows eslint + prettier/prettier)
    ;;; -*- lexical-binding: t; -*-
    ;;; -*- lexical-binding: t; -*-
    ;;; -*- lexical-binding: t; -*-
  (use-package flymake-eslint
    :preface
    (defun me/flymake-eslint-enable-maybe ()
      "Enable `flymake-eslint' based on the project configuration.
  Search for the project ESLint configuration to determine whether the buffer
  should be checked."
      (when-let* ((root (locate-dominating-file (buffer-file-name) "package.json"))
                  (rc (locate-file ".eslintrc" (list root) '(".js" ".json"))))
        (make-local-variable 'exec-path)
        (push (file-name-concat root "node_modules" ".bin") exec-path)
        (flymake-eslint-enable))))

  (use-package flymake
    ;; :straight nil
    :custom
    (flymake-fringe-indicator-position nil))


  (defun my/eslint-fix-buffer ()
    "Run eslint --fix on the current file and reload buffer."
    (interactive)
    (when (and buffer-file-name
               (file-exists-p buffer-file-name))
      (shell-command (format "npx eslint %s --fix"
                             (shell-quote-argument buffer-file-name)))
      (revert-buffer :ignore-auto :noconfirm)))
#+end_src

* Git

#+begin_src emacs-lisp

  (use-package magit
    :commands magit-status
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  ;; NOTE: Make sure to configure a GitHub token before using this package!
  ;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
  ;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started
  (use-package forge 
    :after magit)

#+end_src

** Diff

*** Difftastic

#+begin_src shell :tangle no
  sudo dnf install difftastic
#+end_src

#+begin_src emacs-lisp
  ;; shows git diff almost like vscode, gitlab, github etc.
  (use-package difftastic
    :ensure t
    :init
    ;; Use transient arguments by default (so C-u C-u works nicely)
    (setq difftastic-use-transient-arguments t))

  ;; by default it opens diff in a split window
  ;; let's make it open in a new tab
  (add-to-list 'display-buffer-alist
  	     '("\\*difftastic.*"
  	       (display-buffer-in-tab)
  	       (tab-name . "Difftastic")))
#+end_src

*** Diff-hl

#+begin_src emacs-lisp
  (use-package diff-hl)
  (global-diff-hl-mode)
#+end_src

** Timemachine

#+begin_src emacs-lisp
  (use-package git-timemachine)
#+end_src

* Org

** Spaced repetition

#+begin_src emacs-lisp
  (defun my/update-next-repeat ()
    "Update review metadata for the current org heading."
    (interactive)
    (unless (derived-mode-p 'org-mode)
      (error "Not in org-mode"))

    (unless (org-at-heading-p)
      (org-back-to-heading t))

    (let* ((today (format-time-string "%Y-%m-%d"))
  	 (last-repeat today)
  	 (current-interval (string-to-number
  			    (or (org-entry-get nil "REPEAT_INTERVAL") "1")))
  	 (next-interval (* 2 current-interval))
  	 (next-repeat (format-time-string
  		       "%Y-%m-%d"
  		       (time-add (current-time)
  				 (days-to-time next-interval)))))
      (org-entry-put nil "LAST_REPEAT" last-repeat)
      (org-entry-put nil "REPEAT_INTERVAL" (number-to-string next-interval))
      (org-entry-put nil "SCHEDULED" next-repeat)

      (message "Review updated: NEXT_REPEAT set to %s (interval: %d days)"
  	     next-repeat next-interval)))
#+end_src

* OS operations

** app-launcher
#+begin_src emacs-lisp
  ;;; app-launcher.el --- Launch applications from Emacs -*- lexical-binding: t -*-

  ;; Author: Sebastien Waegeneire
  ;; Created: 2020
  ;; License: GPL-3.0-or-later
  ;; Version: 0.1
  ;; Package-Requires: ((emacs "27.1"))
  ;; Homepage: https://github.com/sebastienwae/app-launcher

  ;; This file is not part of GNU Emacs.

  ;; This program is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

  ;;; Commentary:

  ;; app-launcher define the `app-launcher-run-app' command which uses
  ;; Emacs standard completion feature to select an application installed
  ;; on your machine and launch it.

  ;;; Acknowledgements:

  ;; This package uses code from the Counsel package by Oleh Krehel.
  ;; https://github.com/abo-abo/swiper

  (require 'xdg)
  (require 'cl-seq)

  (defcustom app-launcher-apps-directories
    (mapcar (lambda (dir) (expand-file-name "applications" dir))
  	  (cons (xdg-data-home)
  		(xdg-data-dirs)))
    "Directories in which to search for applications (.desktop files)."
    :type '(repeat directory))

  (defcustom app-launcher--annotation-function #'app-launcher--annotation-function-default
    "Define the function that genereate the annotation for each completion choices."
    :type 'function)

  (defcustom app-launcher--action-function #'app-launcher--action-function-default
    "Define the function that is used to run the selected application."
    :type 'function)

  (defvar app-launcher--cache nil
    "Cache of desktop files data.")

  (defvar app-launcher--cache-timestamp nil
    "Time when we last updated the cached application list.")

  (defvar app-launcher--cached-files nil
    "List of cached desktop files.")

  (defun app-launcher-list-desktop-files ()
    "Return an alist of all Linux applications.
  Each list entry is a pair of (desktop-name . desktop-file).
  This function always returns its elements in a stable order."
    (let ((hash (make-hash-table :test #'equal))
  	result)
      (dolist (dir app-launcher-apps-directories)
        (when (file-exists-p dir)
  	(let ((dir (file-name-as-directory dir)))
  	  (dolist (file (directory-files-recursively dir ".*\\.desktop$"))
  	    (let ((id (subst-char-in-string ?/ ?- (file-relative-name file dir))))
  	      (when (and (not (gethash id hash)) (file-readable-p file))
  		(push (cons id file) result)
  		(puthash id file hash)))))))
      result))

  (defun app-launcher-parse-files (files)
    "Parse the .desktop files to return usable informations."
    (let ((hash (make-hash-table :test #'equal)))
      (dolist (entry files hash)
        (let ((file (cdr entry)))
  	(with-temp-buffer
  	  (insert-file-contents file)
  	  (goto-char (point-min))
  	  (let ((start (re-search-forward "^\\[Desktop Entry\\] *$" nil t))
  		(end (re-search-forward "^\\[" nil t))
  		(visible t)
  		name comment exec)
  	    (catch 'break
  	      (unless start
  		(message "Warning: File %s has no [Desktop Entry] group" file)
  		(throw 'break nil))

  	      (goto-char start)
  	      (when (re-search-forward "^\\(Hidden\\|NoDisplay\\) *= *\\(1\\|true\\) *$" end t)
  		(setq visible nil))
  	      (setq name (match-string 1))

  	      (goto-char start)
  	      (unless (re-search-forward "^Type *= *Application *$" end t)
  		(throw 'break nil))
  	      (setq name (match-string 1))

  	      (goto-char start)
  	      (unless (re-search-forward "^Name *= *\\(.+\\)$" end t)
  		;;(push file counsel-linux-apps-faulty)
  		(message "Warning: File %s has no Name" file)
  		(throw 'break nil))
  	      (setq name (match-string 1))

  	      (goto-char start)
  	      (when (re-search-forward "^Comment *= *\\(.+\\)$" end t)
  		(setq comment (match-string 1)))

  	      (goto-char start)
  	      (unless (re-search-forward "^Exec *= *\\(.+\\)$" end t)
  		;; Don't warn because this can technically be a valid desktop file.
  		(throw 'break nil))
  	      (setq exec (match-string 1))

  	      (goto-char start)
  	      (when (re-search-forward "^TryExec *= *\\(.+\\)$" end t)
  		(let ((try-exec (match-string 1)))
  		  (unless (locate-file try-exec exec-path nil #'file-executable-p)
  		    (throw 'break nil))))

  	      (puthash name
  		       (list (cons 'file file)
  			     (cons 'exec exec)
  			     (cons 'comment comment)
  			     (cons 'visible visible))
  		       hash))))))))

  (defun app-launcher-list-apps ()
    "Return list of all Linux .desktop applications."
    (let* ((new-desktop-alist (app-launcher-list-desktop-files))
  	 (new-files (mapcar 'cdr new-desktop-alist)))
      (unless (and (equal new-files app-launcher--cached-files)
  		 (null (cl-find-if
  			(lambda (file)
  			  (time-less-p
  			   app-launcher--cache-timestamp
  			   (nth 5 (file-attributes file))))
  			new-files)))
        (setq app-launcher--cache (app-launcher-parse-files new-desktop-alist))
        (setq app-launcher--cache-timestamp (current-time))
        (setq app-launcher--cached-files new-files)))
    app-launcher--cache)

  (defun app-launcher--annotation-function-default (choice)
    "Default function to annotate the completion choices."
    (let ((str (cdr (assq 'comment (gethash choice app-launcher--cache)))))
      (when str (concat " - " (propertize str 'face 'completions-annotations)))))

  (defun app-launcher--action-function-default (selected)
    "Default function used to run the selected application."
    (let* ((exec (cdr (assq 'exec (gethash selected app-launcher--cache))))
  	 (command (let (result)
  		    (dolist (chunk (split-string exec " ") result)
  		      (unless (or (equal chunk "%U")
  				  (equal chunk "%F")
  				  (equal chunk "%u")
  				  (equal chunk "%f"))
  			(setq result (concat result chunk " ")))))))
      (call-process-shell-command command nil 0 nil)))

  ;;;###autoload
  (defun app-launcher-run-app (&optional arg)
    "Launch an application installed on your machine.
  When ARG is non-nil, ignore NoDisplay property in *.desktop files."
    (interactive)
    (let* ((candidates (app-launcher-list-apps))
  	 (result (completing-read
  		  "Run app: "
  		  (lambda (str pred flag)
  		    (if (eq flag 'metadata)
  			'(metadata
  			  (annotation-function . (lambda (choice)
  						   (funcall
  						    app-launcher--annotation-function
  						    choice))))
  		      (complete-with-action flag candidates str pred)))
  		  (lambda (x y)
  		    (if arg
  			t
  		      (cdr (assq 'visible y))))
  		  t nil 'app-launcher nil nil)))
      (funcall app-launcher--action-function result)))

  ;; Provide the app-launcher feature
  (provide 'app-launcher)
#+end_src

* Browsing

** Reddit
#+begin_src emacs-lisp
  (use-package reddigg)
#+end_src

